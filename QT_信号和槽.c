//https://www.cnblogs.com/wanghui1234/p/8964968.html
/*
信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）

　　信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。

　　槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。
*/

/*
信号和槽机制是QT的核心机制，要精通QT编程就必须对信号和槽有所了解。信号和槽是一种高级接口，应用于对象之间的通信，他是QT的核心特性，也是QT差别于其他工具包的重要地方。信号和槽是QT自行定义的一种通信机制，他独立于标准的C/C++语言，因此要正确的处理信号和槽，必须借助一个称为moc（Meta Object Compiler）的QT工具，该工具是个C++预处理程式，他为高层次的事件处理自动生成所需要的附加代码。 
在我们所熟知的非常多GUI工具包中，窗口小部件(widget)都有一个回调函数用于响应他们能触发的每个动作，这个回调函数通常是个指向某个函数的指针。不过，在 QT中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程式更为简洁明了。信号和槽能携带任意数量和任意类型的参数，他们是类型完全安全的，不会像回调函数那样产生core dumps。 
所有从QObject或其子类(例如Qwidget)派生的类都能够包含信号和槽。当对象改动其状态时，信号就由该对象发射(emit)出去，这就是对象所要做的全部事情，他不知道另一端是谁在接收这个信号。这就是真正的信息封装，他确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但他们是普通的对象成员函数。一个槽并不知道是否有所有信号和自己相连接。而且，对象并不了解具体的通信机制。 
你能将非常多信号和单个的槽进行连接，也能将单个的信号和非常多的槽进行连接，甚至于将一个信号和另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将即时发射第二个信号。总之，信号和槽构造了一个强大的部件编程机制。 
*/
//如果存在多个槽和某个信号相关联，那么，当这个信号被发射时，这些槽将会一个接一个地执行，不过他们执行的顺序将会是随机的、不确定的，我们不能人为地指定哪个先执行、哪个后执行。


// 应当注意的问题
/*
信号和槽机制是比较灵活的，但有些局限性我们必须了解，这样在实际的使用过程中做到有的放矢，避免产生一些错误。下面就介绍一下这方面的情况。 
（1）信号和槽的效率是非常高的，不过同真正的回调函数比较起来，由于增加了灵活性，因此在速度上还是有所损失，当然这种损失相对来说是比较小的，通过在一台 i586-133的机器上测试是10微秒（运行Linux），可见这种机制所提供的简洁性、灵活性还是值得的。但如果我们要追求高效率的话，比如在实时系统中就要尽可能的少用这种机制。 
（2）信号和槽机制和普通函数的调用相同，如果使用不当的话，在程式执行时也有可能产生死循环。因此，在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。例如,在前面给出的例子中如果在mySlot()槽函数中加上语句emit mySignal()即可形成死循环。 
（3）如果一个信号和多个槽相联系的话，那么，当这个信号被发射时，和之相关的槽被激活的顺序将是随机的。 
（4）宏定义不能用在signal和slot的参数中。 
既然moc工具不扩展#define，因此，在signals和slots中携带参数的宏就不能正确地工作，如果不带参数是能的。
*/